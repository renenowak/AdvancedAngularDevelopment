import { CoreUtils } from "./CoreUtils";
import { ChannelController } from './ChannelController';
"use strict";
var validationError = "Extensions must provide callback to initialize";
var BaseCore = /** @class */ (function () {
    function BaseCore() {
        this._isInitialized = false;
        this._extensions = new Array();
        this._channelController = new ChannelController();
    }
    BaseCore.prototype.initialize = function (config, extensions, logger, notificationManager) {
        var _this = this;
        // Make sure core is only initialized once
        if (this._isInitialized) {
            throw Error("Core should not be initialized more than once");
        }
        if (!config || CoreUtils.isNullOrUndefined(config.instrumentationKey)) {
            throw Error("Please provide instrumentation key");
        }
        this.config = config;
        this._notificationManager = notificationManager;
        if (!this._notificationManager) {
            this._notificationManager = Object.create({
                addNotificationListener: function (listener) { },
                removeNotificationListener: function (listener) { },
                eventsSent: function (events) { },
                eventsDiscarded: function (events, reason) { }
            });
        }
        this.config.extensions = CoreUtils.isNullOrUndefined(this.config.extensions) ? [] : this.config.extensions;
        // add notification to the extensions in the config so other plugins can access it
        this.config.extensionConfig = CoreUtils.isNullOrUndefined(this.config.extensionConfig) ? {} : this.config.extensionConfig;
        if (this._notificationManager) {
            this.config.extensionConfig.NotificationManager = this._notificationManager;
        }
        this.logger = logger;
        if (!this.logger) {
            this.logger = Object.create({
                throwInternal: function (severity, msgId, msg, properties, isUserAct) {
                    if (isUserAct === void 0) { isUserAct = false; }
                },
                warnToConsole: function (message) { },
                resetInternalMessageCount: function () { }
            });
        }
        // Concat all available extensions 
        (_a = this._extensions).push.apply(_a, extensions.concat(this.config.extensions));
        // Initial validation 
        this._extensions.forEach(function (extension) {
            var isValid = true;
            if (CoreUtils.isNullOrUndefined(extension) || CoreUtils.isNullOrUndefined(extension.initialize)) {
                isValid = false;
            }
            if (!isValid) {
                throw Error(validationError);
            }
        });
        // Initial validation complete
        this._extensions.push(this._channelController);
        // Sort by priority
        this._extensions = this._extensions.sort(function (a, b) {
            var extA = a;
            var extB = b;
            var typeExtA = typeof extA.processTelemetry;
            var typeExtB = typeof extB.processTelemetry;
            if (typeExtA === 'function' && typeExtB === 'function') {
                return extA.priority - extB.priority;
            }
            if (typeExtA === 'function' && typeExtB !== 'function') {
                // keep non telemetryplugin specific extensions at start
                return 1;
            }
            if (typeExtA !== 'function' && typeExtB === 'function') {
                return -1;
            }
        });
        // sort complete
        // Check if any two extensions have the same priority, then warn to console
        var priority = {};
        this._extensions.forEach(function (ext) {
            var t = ext;
            if (t && t.priority) {
                if (!CoreUtils.isNullOrUndefined(priority[t.priority])) {
                    if (_this.logger) {
                        _this.logger.warnToConsole("Two extensions have same priority" + priority[t.priority] + ", " + t.identifier);
                    }
                }
                else {
                    priority[t.priority] = t.identifier; // set a value
                }
            }
        });
        var c = -1;
        // Set next plugin for all until channel controller
        for (var idx = 0; idx < this._extensions.length - 1; idx++) {
            var curr = (this._extensions[idx]);
            if (curr && typeof curr.processTelemetry !== 'function') {
                // these are initialized only, allowing an entry point for extensions to be initialized when SDK initializes
                continue;
            }
            if (curr.priority === this._channelController.priority) {
                c = idx + 1;
                break; // channel controller will set remaining pipeline
            }
            this._extensions[idx].setNextPlugin(this._extensions[idx + 1]); // set next plugin
        }
        // initialize channel controller first, this will initialize all channel plugins
        this._channelController.initialize(this.config, this, this._extensions);
        // initialize remaining regular plugins
        this._extensions.forEach(function (ext) {
            var e = ext;
            if (e && e.priority < _this._channelController.priority) {
                ext.initialize(_this.config, _this, _this._extensions); // initialize
            }
        });
        // Remove sender channels from main list
        if (c < this._extensions.length) {
            this._extensions.splice(c);
        }
        if (this.getTransmissionControls().length === 0) {
            throw new Error("No channels available");
        }
        this._isInitialized = true;
        var _a;
    };
    BaseCore.prototype.getTransmissionControls = function () {
        return this._channelController.ChannelControls;
    };
    BaseCore.prototype.track = function (telemetryItem) {
        if (!telemetryItem.iKey) {
            // setup default iKey if not passed in
            telemetryItem.iKey = this.config.instrumentationKey;
        }
        if (!telemetryItem.time) {
            // add default timestamp if not passed in
            telemetryItem.time = new Date().toISOString();
        }
        if (CoreUtils.isNullOrUndefined(telemetryItem.ver)) {
            // CommonSchema 4.0
            telemetryItem.ver = "4.0";
        }
        // invoke any common telemetry processors before sending through pipeline
        if (this._extensions.length === 0) {
            this._channelController.processTelemetry(telemetryItem); // Pass to Channel controller so data is sent to correct channel queues
        }
        var i = 0;
        while (i < this._extensions.length) {
            if (this._extensions[i].processTelemetry) {
                this._extensions[i].processTelemetry(telemetryItem); // pass on to first extension that can support processing
                break;
            }
            i++;
        }
    };
    return BaseCore;
}());
export { BaseCore };
//# sourceMappingURL=BaseCore.js.map